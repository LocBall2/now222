-- Fractucul-Style AutoJoiner - Fixed Version
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

-- Discord configuration
local DISCORD_TOKEN = _G.DISCORD_TOKEN or ""
local DISCORD_GATEWAY = "wss://gateway.discord.gg/?v=10&encoding=json"

-- Chilli Hub channels to monitor
local CHILLI_HUB_CHANNELS = {
    ["under_500k"] = "1394958052536619059",
    ["500k_1m"] = "1394958062166474823", 
    ["500k_1m_alt"] = "1400302142702751864",
    ["1m_10m"] = "1399474388105035988",
    ["1m_10m_alt"] = "1400302392431349770",
    ["10m_plus"] = "1399474419038032024",
}

-- Create main UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "FractuculAutoJoiner"
screenGui.Parent = CoreGui
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main container
local mainContainer = Instance.new("Frame")
mainContainer.Name = "MainContainer"
mainContainer.Size = UDim2.new(0, 400, 0, 450)
mainContainer.Position = UDim2.new(0.05, 0, 0.3, 0)
mainContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
mainContainer.BorderSizePixel = 0
mainContainer.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainContainer

-- Title bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainContainer

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 8)
titleCorner.Parent = titleBar

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -40, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Fractucul AutoJoiner"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 14
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = titleBar

-- Close button
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Size = UDim2.new(0, 30, 1, 0)
closeButton.Position = UDim2.new(1, -30, 0, 0)
closeButton.BackgroundTransparency = 1
closeButton.Text = "X"
closeButton.TextColorÊûÅ = Color3.fromRGB(255, 255, 255)
closeButton.Font = Enum.Font.GothamBold
closeButton.TextSize = 14
closeButton.Parent = titleBar

closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Status panel
local statusPanel = Instance.new("Frame")
statusPanel.Name = "StatusPanel"
statusPanel.Size = UDim2.new(1, -20, 0, 30)
statusPanel.Position = UDim2.new(0, 10, 0, 40)
statusPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
statusPanel.BorderSizePixel = 0
statusPanel.Parent = mainContainer

local statusCorner = Instance.new("UICorner")
statusCorner.CornerRadius = UDim.new(0, 6)
statusÊûÅrner.Parent = statusPanel

local statusLabel = Instance.new("TextLabel")
statusLabel.Name = "StatusLabel"
statusLabel.Size = UDim2.new(1, -10, 1, 0)
statusLabel.Position = UDim2.new(0, 10, 0, 0)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Status: Ready"
statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 12
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = statusPanel

-- Server filter section
local filterPanel = Instance.new("Frame")
filterPanel.Name = "FilterPanel"
filterPanel.Size = UDim2.new(1, -20, 0, 120)
filterPanel.Position = UDim2.new(0, 10, 0, 80)
filterPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
filterPanel.BorderSizePixel = 0
filterPanel.Parent = mainContainer

local filterCorner = Instance.new("UICorner")
filterCorner.CornerRadius = UDim.new(0, 6)
filterCorner.Parent = filterPanel

local filterTitle = Instance.new("TextLabel")
filterTitle.Name = "FilterTitle"
filterTitle.Size = UDim2.new(ÊûÅ, -10, 0, 20)
filterTitle.Position = UDim2.new(0, 10, 0, 5)
filterTitle.BackgroundTransparency = 1
filterTitle.Text = "Server Filters:"
filterTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
filterTitle.Font = Enum.Font.GothamBold
filterTitle.TextSize = 12
filterTitle.TextXAlignment = Enum.TextXAlignment.Left
filterTitle.Parent = filterPanel

-- Minimum money input
local minMoneyContainer = Instance.new("Frame")
minMoneyContainer.Name = "MinMoneyContainer"
minMoneyContainer.Size = UDim2.new(1, -20, 0, 25)
minMoneyContainer.Position = UDim2.new(0, 10, 0, 30)
minMoneyContainer.BackgroundTransparency = 1
minMoneyContainer.Parent = filterPanel

local minMoneyLabel = Instance.new("TextLabel")
minMoneyLabel.Name = "MinMoneyLabel"
minMoneyLabel.Size = UDim2.new(0.5, -5, 1, 0)
minMoneyLabel.Position = UDim2.new(0, 0, 0, 0)
minMoneyLabel.BackgroundTransparency = 1
minMoneyLabel.Text = "Min Money (M):"
minMoneyLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
minMoneyLabel.Font = Enum.Font.Gotham
minMoneyLabel.TextSize = 12
minMoneyLabel.TextXAlignment = Enum.TextXAlignment.Left
minMoneyLabel.Parent = minMoneyContainer

local minMoneyBox = Instance.new("TextBox")
minMoneyBox.Name = "MinMoneyBox"
minMoneyBox.Size = UDim2.new(0.5, -5, 1, 0)
minMoneyBox.Position = UDim2.new(0.5, 5, 0, 0)
minMoneyBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
minMoneyBox.BorderSizePixel = 0
minMoneyBox.Text = "10"
minMoneyBox.TextColor3 = Color3.fromRGB(255, 255, 255)
minMoneyBox.Font = Enum.Font.Gotham
minMoneyBox.TextSize = 12
minMoneyBox.Parent = minMoneyContainer

local minMoneyCorner = Instance.new("UICorner")
minMoneyCorner.CornerRadius = UDim.new(0, 4)
minMoneyCorner.Parent = minMoneyBox

-- Max players input
local maxPlayersContainer = Instance.new("Frame")
maxPlayersContainer.Name = "MaxPlayersContainer"
maxPlayersContainer.Size = UDim2.new(1, -20, 0, 25)
maxPlayersContainer.Position = UDim2.new(0, 10, 0, 60)
maxPlayersContainer.BackgroundTransparency = 1
maxPlayersContainer.Parent = filterPanel

local maxPlayersLabel = Instance.new("TextLabel")
maxPlayersLabel.Name = "ÊûÅaxPlayersLabel"
maxPlayersLabel.Size = UDim2.new(0.5, -5, 1, 0)
maxPlayersLabel.Position = UDim2.new(0, 0, 0, 0)
maxPlayersLabel.BackgroundTransparency = 1
maxPlayersLabel.Text = "Max Players:"
maxPlayersLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
ÊûÅaxPlayersLabel.Font = Enum.Font.Gotham
maxPlayersLabel.TextSize = 12
maxPlayersLabel.TextXAlignment = Enum.TextXAlignment.Left
maxPlayersLabel.Parent = maxPlayersContainer

local maxPlayersBox = Instance.new("TextBox")
maxPlayersBox.Name = "MaxPlayersBox"
maxPlayersBox.Size = UDim2.new(0.5, -5, 1, 0)
maxPlayersBox.Position = UDim2.new(0.5, 5, 0, 0)
maxPlayersBox.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
maxPlayersBox.BorderSizePixel = 0
maxPlayersBox.Text = "6"
maxPlayersBox.TextColor3 = Color3.fromRGB(255, 255, 255)
maxPlayersBox.Font = Enum.Font.Gotham
maxPlayersBox.TextSize = 12
maxPlayersBox.Parent = maxPlayersContainer

local maxPlayersCorner = Instance.new("UICorner")
maxPlayersCorner.CornerRadius = UDim.new(0, 4)
maxPlayersCorner.Parent = maxPlayersBox

-- Channel selection
local channelContainer = Instance.new("Frame")
channelContainer.Name = "ChannelContainer"
channelContainer.Size = UDim2.new(1, -20, 0, 25)
channelContainer.Position = UDim2.new(0, 10, 0, 90)
channelContainer.BackgroundTransparency = 1
channelContainer.Parent = filterPanel

local channelLabel = Instance.new("TextLabel")
channelLabel.Name = "ChannelLabel"
channelLabel.Size = UDim2.new(0.ÊûÅ, -5, 1, 0)
channelLabel.Position = UDimÊûÅ.new(0, 0, 0, 0)
channelLabel.BackgroundTransparency = 1
channelLabel.Text = "Channel:"
channelLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
channelLabel.Font = Enum.Font.Gotham
channelLabel.TextSize = 12
channelLabel.TextXAlignment = Enum.TextXAlignment.Left
channelLabelÊûÅarent = channelContainer

local channelDropdown = Instance.new("TextButton")
channelDropdown.Name = "ChannelDropdown"
channelDropdown.Size = UDim2.new(0.5, -5, 1, 0)
channelDropdown.Position = UDim2.new(0.5, 5, 0, 0)
channelDropdown.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
channelDropdown.BorderSizePixel = 0
channelDropdown.Text = "10m_plus"
channelDropdown.TextColor3 = Color3.fromRGB(255, 255, 255)
channelDropdown.Font = Enum.Font.Gotham
channelDropdown.TextSize = 12
channelDropdown.Parent = channelContainer

local channelCorner = Instance.new("UICorner")
channelCorner.CornerRadius = UDim.new(0, 4)
channelCorner.Parent = channelDropdown

-- Toggle button
local toggleButton = Instance.new("TextButton")
toggleButton.Name = "ToggleButton"
toggleButton.Size = UDim2.new(1, -20, 0, 40)
toggleButton.Position = UDim2.new(0, ÊûÅ0, 0, 210)
toggleButton.BackgroundColor3 = Color3.fromRGB(60, 160, 60)
toggleButton.BorderSizePixel = 0
toggleButton.Text = "START AUTOJOINER"
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 14
toggleButton.Parent = mainContainer

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 6)
toggleCorner.Parent = toggleButton

-- Stats panel
local statsPanel = Instance.new("Frame")
statsPanel.Name = "StatsPanel"
statsPanel.Size = UDim2.new(1, -20, 0, 80)
statsPanel.Position = UDim2.new(0, 10, 0, 260)
statsPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
statsPanel.BorderSizePixel = 0
statsPanel.Parent = mainContainer

local statsCorner = Instance.new("UICorner")
statsCorner.CornerRadius = UDim.new(0, 6)
statsCorner.Parent = statsPanel

local serversLabel = Instance.new("TextLabel")
serversLabel.Name = "ServersLabel"
serversLabel.Size = UDim2.new(0.5, -5, 0.5, -5)
serversLabel.Position = UDim2.new(0, 10, 0, 10)
serversLabel.BackgroundTransparency = 1
serversLabel.Text = "Servers: 0"
serversLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
serversLabel.Font = Enum.Font.Gotham
serversLabel.TextSize = 12
serversLabel.TextXAlignment = Enum.TextXAlignment.Left
serversLabel.Parent = statsPanel

local moneyLabel = Instance.new("TextLabel")
moneyLabel.Name = "MoneyLabel"
moneyLabel.Size = UDim2.new(0.5, -5, 0.5, -5)
moneyLabel.Position = UDim2.new(0.5, 5, 0, 10)
moneyLabel.BackgroundTransparency = 1
moneyLabel.Text = "Money: $0"
moneyLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
moneyLabel.Font = Enum.Font.Gotham
moneyLabel.TextSize = 12
moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
moneyLabel.Parent = statsPanel

local lastServerLabel = Instance.new("TextLabel")
lastServerLabel.Name = "LastServerLabel"
lastServerLabel.Size = UDim2.new(1, -20, 0.5, -5)
lastServerLabel.Position = UDim2.new(0, 10, 0.5, 5)
lastServerLabel.BackgroundTransparency = 1
lastServerLabel.Text = "Last: None"
lastServerLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
lastServerLabel.Font = Enum.Font.Gotham
lastServerLabel.TextSize = 12
lastServerLabel.TextXAlignment = Enum.TextXAlignment.Left
lastServerLabel.Parent = statsPanel

-- Log panel
local logPanel = Instance.new("ScrollingFrame")
logPanel.Name = "LogPanel"
logPanel.Size = UDim2.new(1, -20, 0, 80)
logPanel.Position = UDim2.new(0, 10, 0, 350)
logPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
logPanel.BorderSizePixel = 0
logPanel.ScrollBarThickness = 5
logPanel.CanvasSize = UDim2.new(0, 0, 2, 0)
logPanel.Parent = mainContainer

local logCorner = Instance.new("UICorner")
logCorner.CornerRadius = UDim.new(0, 6)
logCorner.ParentÊûÅlogPanel

local logLayout = Instance.new("UIListLayout")
logLayout.Parent = logPanel
logLayout.SortOrder = Enum.SortOrder.LayoutOrder
logLayout.Padding = UDim.new(0, 2)

-- AutoJoiner logic
local isRunning = false
local serversJoined = 0
local totalMoney = 0
local websocket = nil
local logs = {}
local heartbeatInterval = nil
local lastSequence = nil

-- Check if token is provided
if DISCORD_TOKEN == "" then
    statusLabel.Text = "Error: Execute with _G.DISCORD_TOKEN"
else
    statusLabel.Text = "Token found! Ready to start"
end

-- Function to add log message
local function addLog(message)
    local timestamp = os.date("%H:%M:%S")
    local logText = timestamp .. " - " .. message
    
    table.insert(logs, logText)
    if #logs > 20 then
        table.remove(logs, 1)
    end
    
    -- Clear existing logs
    for _, child in ipairs(logPanel:GetChildren()) do
        if child:IsA("TextLabel") then
            child:Destroy()
        end
    end
    
    -- Add all logs
    for i, log in ipairs(logs) do
        local logLabel = Instance.new("TextLabel")
        logLabel.Size = UDim2.new(1, -10, 0, 16)
        logLabel.Position = UDim2.new(0, 5, 0, (i-1)*18)
        logLabel.BackgroundTransparency = 1
        logLabel.Text = log
        logLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
        logLabel.Font = Enum.Font.Gotham
        logLabel.TextSize = 11
        logLabel.TextXAlignment = Enum.TextXAlignment.Left
        logLabel.TextTruncate = Enum.TextTruncate.AtEnd
        logLabel.Parent = logPanel
    end
    
    -- Adjust canvas size
    logPanel.CanvasSize = UDim2.new(0, 0, 0, #logs * 18)
end

-- Function to parse money from string
local function parseMoney(moneyStr)
    if not moneyStr then return 0 end
    local cleanStr = string.gsub(moneyStr, "[^%d%.]", "")
    if string.find(moneyStr, "K") then
        return tonumber(cleanStr) * 1000
    elseif string.find(moneyStr, "M") then
        return tonumber(cleanStr) * 1000000
    else
        return tonumber(cleanStr) or 0
    end
end

-- Function to extract server info from Discord message
local function extractServerInfo(messageData)
    local info = {
        name = "Unknown",
        money = 0,
        players = "0/8",
        jobId = nil
    }
    
    -- First, try to extract from content if it's a direct message
    local content = messageData.content or ""
    
    -- Look for Job ID first (most important)
    local jobIdMatch = string.match(content, "Job ID %(PC%)[^\n]-%`([^%`]+)%`")
    if not jobIdMatch then
        jobIdMatch = string.match(content, "Job ID %(PC%)[^\n]-([%w%=]+)")
    end
    if not jobIdMatch then
        jobIdMatch = string.match(content, "7IRZ[%w=]+") -- Common Chilli Hub pattern
    end
    if not jobIdMatch then
        -- Try to find any base64-like string that might be a job ID
        jobIdMatch = string.match(content, "[%w+/]+=*")
    end
    
    if jobIdMatch and #jobIdMatch > 10 then
        info.jobId = jobIdMatch
    end
    
    -- Look for money pattern
    local moneyMatch = string.match(content, "üí∞ Money per sec[^%d]*(%d+%.?%d*[MK]?)")
    if not moneyMatch then
        moneyMatch = string.match(content, "Money per sec[^%d]*(%d+%.?%d*[MK]?)")
    end
    if moneyMatch then
        info.money = parseMoney(moneyMatch)
    end
    
    -- Look for players pattern
    local playersMatch = string.match(content, "üë• Players[^%d]*(%d+/%d+)")
    if not playersMatch then
        playersMatch = string.match(content, "Players[^%d]*(%d+/%d+)")
    end
    if playersMatch then
        info.players = playersMatch
    end
    
    -- Look for server name
    local nameMatch = string.match(content, "üè∑Ô∏è Name[^\n]-%*([^%*]+)%*")
    if not nameMatch then
        nameMatch = string.match(content, "Name[^\n]-%*([^%ÊûÅ]+)%*")
    end
    if nameMatch then
        info.name = nameMatch
    end
    
    -- Check if message has embeds as fallback
    if messageData.embeds and #messageData.embeds > 0 then
        local embed = messageData.embeds[1]
        
        -- Extract from embed title
        if embed.title and info.name == "Unknown" then
            local nameMatch = string.match(embed.title, "[^-|‚Ä¢]*$")
            if nameÊûÅtch then
                info.name = nameMatch:gsub("^%s*(.-)%s*$", "%1")
            end
        end
        
        -- Extract from embed description
        if embed.description then
            -- Look for money pattern
            if info.money == 0 then
                local moneyMatch = string.match(embed.description, "Money per sec[^%d]*(%d+%.?%d*[MK]?)")
                if moneyMatch then
                    info.money = parseMoney(moneyMatch)
                end
            end
            
            -- Look for players pattern
            if info.players == "0/8" then
                local playersMatch = string.match(embed.description, "Players[^%d]*(%d+/%d+)")
                if playersMatch then
                    info.players = playersMatch
                end
            end
            
            -- Look for Job ID (PC) - most important
            if not info.jobId then
                local jobIdMatch = string.match(embed.description, "Job ID %(PC%)[^\n]-%`([^%`]+)%`")
                if not jobIdMatch then
                    jobIdMatch = string.match(embed.description, "Job ID %(PC%)[^\n]-([%w%=]+)")
                end
                if jobIdMatch then
                    info.jobId = jobIdMatch
                end
            end
        end
        
        -- Extract from embed fields
        if embed.fields then
            for _, field in ipairs(embed.fields) do
                if (field.name == "Money per sec" or field.name == "üí∞ Money per sec") and info.money == 0 then
                    info.money = parseMoney(field.value)
                elseif (field.name == "Players" or field.name == "üë• Players") and info.players == "0/8" then
                    info.players = field.value
                elseif (field.name == "Name" or field.name == "üè∑Ô∏è Name") and info.name == "Unknown" then
                    info.name = field.value:gsub("%*", "")
                elseif field.name == "Job ID (PC)" and not info.jobId then
                    info.jobId = field.value:gsub("`", "")
                end
            end
        end
    end
    
    -- Debug logging to help identify parsing issues
    if info.jobId then
        addLog("Parsed server: " .. info.name .. " | Money: " .. info.money .. " | Players: " .. info.players)
    else
        addLog("Could not parse job ID from message")
        if content and content ~= "" then
            addLog("Message content: " .. string.sub(content, 1, 100) .. "...")
        end
    end
    
    return info
end

-- Function to join a job instantly
local function joinJobInstantly(jobId, money, players, serverName)
    if not jobId or jobId == "" or #jobId < 10 then
        statusLabel.Text = "Invalid Job ID"
        addLog("Invalid Job ID: " .. tostring(jobId))
        return false
    end
    
    -- Get current filter values
    local minMoneyValue = tonumber(minMoneyBox.Text) or 10
    local maxPlayersValue = tonumber(maxPlayersBox.Text) or 6
    
    -- Check if server meets criteria
    local moneyValue = money or 0
    local currentPlayers = tonumber(string.match(players, "(%d+)/")) or 0
    local maxServerPlayers = tonumber(string.match(players, "/(%d+)")) or 8
    
    if moneyValue < minMoneyValue * 1000000 then
        statusLabel.Text = "Skipped: Money too low (" .. (moneyValue/1000000) .. "M)"
        addLog("Skipped: Money too low (" .. (moneyValue/1000000) .. "M)")
        return false
    end
    
    if currentPlayers >= maxPlayersValue then
        statusLabel.Text = "Skipped: Server full (" .. players .. ")"
        addLog("Skipped: Server full (" .. players .. ")")
        return false
    end
    
    -- Join the server instantly
    statusLabel.Text = "Joining " .. (serverName or "server") .. "..."
    addLog("Joining " .. (serverName or "server") .. " (" .. players .. ")")
    lastServerLabel.Text = "Last: " .. (serverName or "Unknown")
    
    -- Use Roblox's TeleportService to join the server
    local success, result = pcall(function()
        TeleportService:TeleportToPlaceInstance(game.PlaceId, jobId, player)
    end)
    
    if success then
        serversJoined = serversJoined + 1
        totalMoney = totalMoney + moneyValue
        serversLabel.Text = "Servers: " .. serversJoined
        moneyLabel.Text = "Money: $" .. string.format("%.2fM", totalMoney/1000000)
        statusLabel.Text = "Joined successfully!"
        addLog("Successfully joined server!")
        return true
    else
        statusLabel.Text = "Failed to join: Server unavailable"
        addLog("Failed to join: " .. tostring(result))
        return false
    end
end

-- Function to send heartbeat to Discord
local function sendHeartbeat()
    if websocket and websocket.Connected then
        local payload = {
            op = 1,
            d = lastSequence
        }
        websocket:Send(HttpService:JSONEncode(payload))
    end
end

-- Function to connect to Discord Gateway directly
local function connectToDiscordGateway()
    if DISCORD_TOKEN == "" then
        statusLabel.Text = "Error: No Discord token"
        addLog("Error: No Discord token provided")
        return false
    end
    
    statusLabel.Text = "Connecting to Discord..."
    addLog("Connecting to Discord gateway...")
    
    local success, ws = pcall(function()
        -- Try different WebSocket connection methods
        if syn and syn.websocket then
            return syn.websocket.connect(DISCORD_GATEWAY)
        elseif WebSocket then
            return WebSocket.connect(DISCORD_GATEWAY)
        else
            error("No WebSocket implementation found")
        end
    end)
    
    if success and ws then
        websocket = ws
        statusLabel.Text = "Connected to Discord Gateway!"
        addLog("Connected to Discord gateway")
        
        -- Listen for messages
        websocket.OnMessage:Connect(function(message)
            local success, data = pcall(function()
                return HttpService:JSONDecode(message)
            end)
            
            if success and data then
                -- Store sequence number for heartbeats
                if data.s then
                    lastSequence = data.s
                end
                
                -- Handle Discord Gateway events
                if data.op == 10 then -- Hello
                    addLog("Discord handshake received")
                    heartbeatInterval = data.d.heartbeat_interval / 1000
                    
                    -- Send identify payload (USER token format)
                    local identifyPayload = {
                        op = 2,
                        d = {
                            token = DISCORD_TOKEN,
                            properties = {
                                os = "Windows",
                                browser = "Chrome", 
                                device = ""
                            },
                            intents = 513, -- GUILD_MESSAGES + MESSAGE_CONTENT
                            presence = {
                                status = "online",
                                afk = false
                            }
                        }
                    }
                    
                    local success, err = pcall(function()
                        websocket:Send(HttpService:JSONEncode(identifyPayload))
                    end)
                    
                    if not success then
                        statusLabel.Text = "Failed to identify: " .. tostring(err)
                        addLog("Failed to identify with Discord: " .. tostring(err))
                        return false
                    end
                    
                    addLog("Sent identify payload to Discord")
                    
                    -- Start heartbeat timer
                    spawn(function()
                        while websocket and websocket.Connected do
                            sendHeartbeat()
                            wait(heartbeatInterval)
                        end
                    end)
                    
                elseif data.t == "MESSAGE_CREATE" then
                    if isRunning then
                        local channelId = data.d.channel_id
                        
                        -- Check if message is from selected channel
                        local selectedChannel = CHILLI_HUB_CHANNELS[channelDropdown.Text]
                        if channelId == selectedChannel then
                            -- Extract server info from message (including embeds)
                            local serverInfo = extractServerInfo(data.d)
                            if serverInfo.jobId then
                                addLog("Found server: " .. serverInfo.name)
                                joinJobInstantly(serverInfo.jobId, serverInfo.money, serverInfo.players, serverInfo.name)
                            else
                                addLog("No valid job ID found in message")
                            end
                        end
                    end
                elseif data.op == 11 then -- Heartbeat ACK
                    -- Heartbeat acknowledged
                elseif data.op == 9 then -- Invalid session
                    addLog("Invalid session, reconnecting...")
                    wait(2)
                    connectToDiscordGateway()
                end
            end
        end)
        
        websocket.OnClose:Connect(function()
            statusLabel.Text = "Discord connection closed"
            addLog("Discord connection closed")
            websocket = nil
            if isRunning then
                wait(3)
                connectToDiscordGateway()
            end
        end)
        
        return true
    else
        statusLabel.Text = "Failed to connect to Discord"
        addLog("Failed to connect to Discord gateway: " .. tostring(ws))
        return false
    end
end

-- Toggle button functionality
toggleButton.MouseButton1Click:Connect(function()
    if DISCORD_TOKEN == "" then
        statusLabel.Text = "Error: Execute with _G.DISCORD_TOKEN"
        addLog("Error: No Discord token provided")
        return
    end
    
    isRunning = not isRunning
    
    if isRunning then
        toggleButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
        toggleButton.Text = "STOP AUTOJOINER"
        addLog("AutoJoiner started")
        connectToDiscordGateway()
    else
        toggleButton.BackgroundColor3 = Color3.fromRGB(60, 160, 60)
        toggleButton.TextÊûÅ "START AUTOJOINER"
        addLog("AutoJoiner stopped")
        if websocket then
            websocket:Close()
            websocket = nil
        end
        statusLabel.Text = "Stopped - Ready"
    end
end)

-- Channel dropdown functionality
local channelOptions = {"under_500k", "500k_1m", "500k_1m_alt", "1ÊûÅ_10m", "1m_10m_alt", "10m_plus"}
local dropdownOpen = false
local dropdownFrame = nil

local function toggleDropdown()
    if dropdownOpen then
        if dropdownFrame then
            dropdownFrame:Destroy()
            dropdownFrame = nil
        end
        dropdownOpen = false
        return
    end
    
    dropdownOpen = true
    
    dropdownFrame = Instance.new("Frame")
    dropdownFrame.Name = "ChannelDropdownOptions"
    dropdownFrame.Size = UDim2.new(0, channelDropdown.AbsoluteSize.X, 0, #channelOptions * 25)
    dropdownFrame.Position = UDim2.new(0, channelDropdown.AbsolutePosition.X - mainContainer.AbsolutePosition.X, 0, channelDropdown.AbsolutePosition.Y - mainContainer.AbsolutePosition.Y + channelDropdown.AbsoluteSize.Y)
    dropdownFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    dropdownFrame.BorderSizePixel = 0
    dropdownFrame.Parent = mainContainer
    dropdownFrame.ZIndex = 10
    
    local dropdownCorner = Instance.new("UICorner")
    dropdownCorner.CornerRadius = UDim.new(0, 4)
    dropdownCorner.Parent = dropdownFrame
    
    local dropdownLayout = Instance.new("UIListLayout")
    dropdownLayout.Parent = dropdownFrame
    
    for _, option in ipairs(channelOptions) do
        local optionButton = Instance.new("TextButton")
        optionButton.Size = UDim2.new(1, 0, 0, 25)
        optionButton.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        optionButton.BorderSizePixel = 0
        optionButton.Text = option
        optionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        optionButton.Font = Enum.Font.Gotham
        optionButton.TextSize = 12
        optionButton.Parent = dropdownFrame
        
        optionButton.MouseButton1Click:Connect(function()
            channelDropdown.Text = option
            addLog("Channel set to: " .. option)
            toggleDropdown()
        end)
    end
end

channelDropdown.MouseButton1Click:Connect(toggleDropdown)

-- Make the window draggable
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.PositionÊûÅ dragStart
    mainContainer.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainContainer.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Close dropdown when clicking elsewhere
UserInputService.InputBegan:Connect(function(input)
    if dropdownOpen and input.UserInputType == Enum.UserInputType.MouseButton1 then
        local mousePos = input.Position
        local dropdownPos = dropdownFrame and dropdownFrame.AbsolutePosition
        local dropdownSize = dropdownFrame and dropdownFrame.AbsoluteSize
        
        if dropdownPos and dropdownSize then
            if not (mousePos.X >= dropdownPos.X and mousePos.X <= dropdownPos.X + dropdownSize.X and
                   mousePos.Y >= dropdownPos.Y and mousePos.Y <= dropdownPos.Y + dropdownSize.Y) then
                toggleDropdown()
            end
        end
    end
end)

-- Initial setup
statusLabel.Text = "Ready - Start AutoJoiner"
serversLabel.Text = "Servers: 0"
moneyLabel.Text = "Money: $0"
lastServerLabel.Text = "Last: None"
addLog("Fractucul AutoJoiner initialized")
addLog("Select channel and click START")

print("Fractucul-Style AutoJoiner loaded!")
print("This is a pure script solution - no external programs needed")
print("Make sure to execute with your USER Discord token (not bot token)")
print("Click START AUTOJOINER to begin monitoring Discord channels")
